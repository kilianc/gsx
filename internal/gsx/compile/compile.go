package compile

import (
	"bytes"
	"fmt"
	goast "go/ast"
	"go/format"
	"go/parser"
	gotoken "go/token"
	"reflect"
	"sort"
	"strconv"
	"strings"

	"github.com/kilianc/gsx/internal/gsx/ast"
	"github.com/kilianc/gsx/internal/gsx/gomponents"
)

const (
	SoftHeader        = "// Code generated by gsxgo. Edits may be overwritten on regen.\n"
	StaticcheckHeader = "//lint:file-ignore ST1001 dot imports are required in generated code\n"
)

const maxSingleLineCallLen = 80

// CompileFile compiles a Go-first .gsx source (a Go file with embedded `<tag>` expressions)
// into a gofmt'd Go source file.
func CompileFile(path string, src []byte) ([]byte, error) {
	rewritten, mapping, err := rewriteTagsToPlaceholders(src)
	if err != nil {
		return nil, err
	}
	rewritten = normalizeParenWrappedPlaceholder(rewritten)

	fset := gotoken.NewFileSet()
	af, err := parser.ParseFile(fset, path+".go", rewritten, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("%w\n\n-- rewritten preview --\n%s", err, previewLines(string(rewritten), 80))
	}

	// Infer which locals are Nodes (defined from GSX placeholders) so `{ident}` splicing works.
	ctx := gomponents.Context{VarTypes: inferVarTypesFromPlaceholders(af, mapping)}

	// Lower placeholders now that we have context.
	for i := range mapping {
		ex, err := gomponents.LowerNodes([]ast.Node{mapping[i].node}, ctx)
		if err != nil {
			return nil, err
		}
		clearTokenPos(ex)
		mapping[i].expr = ex
	}

	// Ensure required imports.
	ensureImports(af, mapping)

	var buf bytes.Buffer
	if err := format.Node(&buf, fset, af); err != nil {
		return nil, err
	}

	gofmted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}

	pretty, err := substitutePlaceholdersWithPrettyExprs(string(gofmted), mapping, maxSingleLineCallLen)
	if err != nil {
		return nil, err
	}

	out := append([]byte(nil), []byte(SoftHeader)...)
	out = append(out, []byte(strings.TrimRight(StaticcheckHeader, "\n"))...)
	out = append(out, '\n', '\n')
	out = append(out, []byte(formatImportGroups(pretty))...)
	final, err := format.Source(out)
	if err != nil {
		// If gofmt fails here, still return a useful error with the raw output.
		return nil, fmt.Errorf("gofmt final: %w\n\n-- output preview --\n%s", err, previewLines(string(out), 120))
	}
	return final, nil
}

func inferVarTypesFromPlaceholders(f *goast.File, phs []placeholder) map[string]string {
	phNames := map[string]bool{}
	for _, p := range phs {
		phNames[p.name] = true
	}

	out := map[string]string{}
	goast.Inspect(f, func(n goast.Node) bool {
		switch t := n.(type) {
		case *goast.AssignStmt:
			// x := __gsx_expr_1()
			for i := range t.Rhs {
				ce, isCall := t.Rhs[i].(*goast.CallExpr)
				if i < len(t.Lhs) {
					if lhsID, ok := t.Lhs[i].(*goast.Ident); ok {
						// Node assignment from placeholder call.
						if isCall {
							id, ok2 := ce.Fun.(*goast.Ident)
							if ok2 && phNames[id.Name] && len(ce.Args) == 0 {
								out[lhsID.Name] = "Node"
								continue
							}
						}
						// Simple string inference.
						if isExprStringish(t.Rhs[i]) {
							out[lhsID.Name] = "string"
							continue
						}
					}
				}
			}
		case *goast.ValueSpec:
			// Respect explicit types, e.g. `var lis []Node` so `{lis}` can splice as children.
			if t.Type != nil {
				typ := typeString(t.Type)
				if typ != "" {
					for _, nm := range t.Names {
						out[nm.Name] = typ
					}
				}
			}
			// var x = __gsx_expr_1()
			for i := range t.Values {
				ce, isCall := t.Values[i].(*goast.CallExpr)
				if i < len(t.Names) {
					// Node assignment from placeholder call.
					if isCall {
						id, ok2 := ce.Fun.(*goast.Ident)
						if ok2 && phNames[id.Name] && len(ce.Args) == 0 {
							out[t.Names[i].Name] = "Node"
							continue
						}
					}
					// Simple string inference.
					if isExprStringish(t.Values[i]) {
						out[t.Names[i].Name] = "string"
						continue
					}
				}
			}
		}
		return true
	})
	return out
}

func typeString(t goast.Expr) string {
	switch tt := t.(type) {
	case *goast.Ident:
		switch tt.Name {
		case "Node":
			return "Node"
		case "Group":
			// Group implements Node, but for our purposes "Node" is enough.
			return "Node"
		case "string":
			return "string"
		}
	case *goast.ArrayType:
		if tt.Len == nil {
			if id, ok := tt.Elt.(*goast.Ident); ok {
				if id.Name == "Node" {
					return "[]Node"
				}
				if id.Name == "string" {
					return "[]string"
				}
			}
		}
	}
	return ""
}

func isExprStringish(e goast.Expr) bool {
	// string literal
	if bl, ok := e.(*goast.BasicLit); ok && bl.Kind == gotoken.STRING {
		return true
	}
	// fmt.Sprintf(...)
	if ce, ok := e.(*goast.CallExpr); ok {
		if sel, ok := ce.Fun.(*goast.SelectorExpr); ok {
			if x, ok := sel.X.(*goast.Ident); ok && x.Name == "fmt" && sel.Sel != nil && sel.Sel.Name == "Sprintf" {
				return true
			}
		}
		// strconv.Itoa(...)
		if sel, ok := ce.Fun.(*goast.SelectorExpr); ok {
			if x, ok := sel.X.(*goast.Ident); ok && x.Name == "strconv" && sel.Sel != nil && sel.Sel.Name == "Itoa" {
				return true
			}
		}
	}
	return false
}

func normalizeParenWrappedPlaceholder(src []byte) []byte {
	// The Go parser doesn't accept some "paren-wrapped expression" forms the way people expect,
	// e.g.:
	//   return (
	//     <div>...</div>
	//   )
	//   top := (
	//     <div>...</div>
	//   )
	//
	// After tag rewriting this becomes `__gsx_expr_N()`. We normalize the specific
	// 3-line pattern:
	//   <stmt-prefix> (
	//     __gsx_expr_N()
	//   )
	// to:
	//   <stmt-prefix> __gsx_expr_N()
	//
	// This keeps `.gsx` ergonomic without requiring us to fully parse Go here.
	lines := strings.Split(string(src), "\n")
	var out []string

	i := 0
	for i < len(lines) {
		line := lines[i]
		trim := strings.TrimSpace(line)

		if strings.HasSuffix(trim, "(") {
			// keep the original leading whitespace indentation
			indent := line[:len(line)-len(strings.TrimLeft(line, " \t"))]
			prefix := strings.TrimSpace(strings.TrimSuffix(trim, "("))

			// expect next line: placeholder call and then a close paren line
			if i+2 < len(lines) {
				exprLine := strings.TrimSpace(lines[i+1])
				closeLine := strings.TrimSpace(lines[i+2])
				if strings.HasPrefix(exprLine, "__gsx_expr_") && strings.HasSuffix(exprLine, "()") && closeLine == ")" {
					out = append(out, indent+prefix+" "+exprLine)
					i += 3
					continue
				}
			}
		}
		out = append(out, line)
		i++
	}
	return []byte(strings.Join(out, "\n"))
}

func previewLines(s string, max int) string {
	lines := strings.Split(s, "\n")
	if len(lines) > max {
		lines = lines[:max]
	}
	for i := range lines {
		lines[i] = fmt.Sprintf("%2d| %s", i+1, lines[i])
	}
	return strings.Join(lines, "\n")
}

type placeholder struct {
	name string
	node ast.Node
	expr goast.Expr
}

func rewriteTagsToPlaceholders(src []byte) ([]byte, []placeholder, error) {
	s := &scanner{src: src}
	var out strings.Builder
	var phs []placeholder

	for !s.eof() {
		if s.startsWith("//") {
			out.WriteString(s.readLineComment())
			continue
		}
		if s.startsWith("/*") {
			out.WriteString(s.readBlockComment())
			continue
		}
		switch s.peek() {
		case '"':
			out.WriteString(s.readStringLit())
			continue
		case '\'':
			out.WriteString(s.readRuneLit())
			continue
		case '`':
			out.WriteString(s.readRawString())
			continue
		case '<':
			// Disambiguate: treat as tag only if next char is an identifier start.
			if b := s.peekN(1); isTagStart(b) {
				el, err := parseTagExpr(s)
				if err != nil {
					return nil, nil, err
				}
				name := "__gsx_expr_" + strconv.Itoa(len(phs)+1)
				phs = append(phs, placeholder{name: name, node: el})
				out.WriteString(name)
				out.WriteString("()")
				continue
			}
		}
		out.WriteByte(s.next())
	}
	return []byte(out.String()), phs, nil
}

func ensureImports(f *goast.File, phs []placeholder) {
	// We always need dot imports for gomponents + html when any tags exist.
	needsTags := len(phs) > 0

	needsFmt := fileUsesPkgSelector(f, "fmt") || anyPlaceholderUsesPkgSelector(phs, "fmt")
	needsComponents := fileUsesIdent(f, "JoinAttrs") || fileUsesIdent(f, "Classes") || anyPlaceholderUsesIdent(phs, "JoinAttrs") || anyPlaceholderUsesIdent(phs, "Classes")

	// Drop any existing imports of these paths; we'll re-add with dot import as needed.
	drop := map[string]bool{
		"maragu.dev/gomponents":            true,
		"maragu.dev/gomponents/html":       true,
		"maragu.dev/gomponents/components": true,
	}

	var keep []*goast.ImportSpec
	existing := map[string]*goast.ImportSpec{}
	for _, imp := range f.Imports {
		p := strings.Trim(imp.Path.Value, `"`)
		if drop[p] {
			continue
		}
		existing[p] = imp
		keep = append(keep, imp)
	}

	var add []impSpec
	if needsTags {
		add = append(add,
			impSpec{name: ".", path: "maragu.dev/gomponents"},
			impSpec{name: ".", path: "maragu.dev/gomponents/html"},
		)
	}
	if needsComponents {
		add = append(add, impSpec{name: ".", path: "maragu.dev/gomponents/components"})
	}
	if needsFmt {
		add = append(add, impSpec{name: "", path: "fmt"})
	}

	// Build final import list, de-duping by path+name.
	type key struct{ name, path string }
	seen := map[key]bool{}
	var specs []*goast.ImportSpec

	for _, imp := range keep {
		k := key{name: "", path: strings.Trim(imp.Path.Value, `"`)}
		if imp.Name != nil {
			k.name = imp.Name.Name
		}
		if !seen[k] {
			seen[k] = true
			specs = append(specs, imp)
		}
	}
	for _, a := range add {
		k := key{name: a.name, path: a.path}
		if seen[k] {
			continue
		}
		seen[k] = true
		var nameIdent *goast.Ident
		if a.name != "" {
			nameIdent = goast.NewIdent(a.name)
		}
		specs = append(specs, &goast.ImportSpec{
			Name: nameIdent,
			Path: &goast.BasicLit{Kind: gotoken.STRING, Value: strconv.Quote(a.path)},
		})
	}

	if len(specs) == 0 {
		return
	}

	// Sort imports by path then name for determinism.
	sort.Slice(specs, func(i, j int) bool {
		pi := strings.Trim(specs[i].Path.Value, `"`)
		pj := strings.Trim(specs[j].Path.Value, `"`)
		if pi != pj {
			return pi < pj
		}
		ni := ""
		nj := ""
		if specs[i].Name != nil {
			ni = specs[i].Name.Name
		}
		if specs[j].Name != nil {
			nj = specs[j].Name.Name
		}
		return ni < nj
	})

	// Remove existing import decls and replace with a single import decl.
	var newDecls []goast.Decl
	for _, d := range f.Decls {
		gd, ok := d.(*goast.GenDecl)
		if ok && gd.Tok == gotoken.IMPORT {
			continue
		}
		newDecls = append(newDecls, d)
	}
	f.Decls = newDecls
	f.Imports = specs

	impDecl := &goast.GenDecl{Tok: gotoken.IMPORT}
	for _, s := range specs {
		impDecl.Specs = append(impDecl.Specs, s)
	}

	// Insert import decl right after package decl (at start of Decls).
	f.Decls = append([]goast.Decl{impDecl}, f.Decls...)
}

func anyPlaceholderUsesPkgSelector(phs []placeholder, pkg string) bool {
	for _, p := range phs {
		if exprUsesPkgSelector(p.expr, pkg) {
			return true
		}
	}
	return false
}

func anyPlaceholderUsesIdent(phs []placeholder, name string) bool {
	for _, p := range phs {
		if exprUsesIdent(p.expr, name) {
			return true
		}
	}
	return false
}

func exprUsesPkgSelector(e goast.Expr, pkg string) bool {
	found := false
	goast.Inspect(e, func(n goast.Node) bool {
		if found || n == nil {
			return false
		}
		sel, ok := n.(*goast.SelectorExpr)
		if !ok {
			return true
		}
		id, ok := sel.X.(*goast.Ident)
		if ok && id.Name == pkg {
			found = true
			return false
		}
		return true
	})
	return found
}

func exprUsesIdent(e goast.Expr, name string) bool {
	found := false
	goast.Inspect(e, func(n goast.Node) bool {
		if found || n == nil {
			return false
		}
		id, ok := n.(*goast.Ident)
		if ok && id.Name == name {
			found = true
			return false
		}
		return true
	})
	return found
}

type impSpec struct {
	name string
	path string
}

func substitutePlaceholdersWithPrettyExprs(src string, phs []placeholder, maxLen int) (string, error) {
	out := src
	for _, p := range phs {
		pretty := prettyExpr(p.expr, maxLen, 0)
		out = replaceAllWithIndent(out, p.name+"()", pretty)
	}
	return out, nil
}

func replaceAllWithIndent(src, needle, replacement string) string {
	if !strings.Contains(src, needle) {
		return src
	}

	var b strings.Builder
	i := 0
	for {
		j := strings.Index(src[i:], needle)
		if j < 0 {
			b.WriteString(src[i:])
			break
		}
		j += i

		// Determine indentation prefix for this occurrence.
		lineStart := strings.LastIndexByte(src[:j], '\n')
		prefix := ""
		if lineStart >= 0 {
			k := lineStart + 1
			for k < len(src) && (src[k] == '\t' || src[k] == ' ') {
				k++
			}
			prefix = src[lineStart+1 : k]
		}

		b.WriteString(src[i:j])
		b.WriteString(applyIndent(prefix, replacement))
		i = j + len(needle)
	}
	return b.String()
}

func applyIndent(prefix, s string) string {
	if !strings.Contains(s, "\n") {
		return s
	}
	lines := strings.Split(s, "\n")
	for i := 1; i < len(lines); i++ {
		lines[i] = prefix + lines[i]
	}
	return strings.Join(lines, "\n")
}

func prettyExpr(e goast.Expr, maxLen int, depth int) string {
	switch t := e.(type) {
	case *goast.CallExpr:
		return prettyCall(t, maxLen, depth)
	default:
		return oneLineGoExpr(e)
	}
}

func prettyCall(c *goast.CallExpr, maxLen int, depth int) string {
	fun := oneLineGoExpr(c.Fun)

	// Build one-line candidate.
	var argOnes []string
	hasMulti := false
	for _, a := range c.Args {
		as := prettyExpr(a, maxLen, depth+1)
		if strings.Contains(as, "\n") {
			hasMulti = true
		}
		argOnes = append(argOnes, oneLineFromMaybeMulti(as))
	}
	one := fun + "(" + strings.Join(argOnes, ", ") + ")"
	if !hasMulti && len(one) <= maxLen {
		return one
	}

	// Multiline: one arg per line.
	var b strings.Builder
	b.WriteString(fun)
	b.WriteString("(\n")
	for _, a := range c.Args {
		as := prettyExpr(a, maxLen, depth+1)
		as = indentLines(as, "\t")
		b.WriteString(as)
		b.WriteString(",\n")
	}
	b.WriteString(")")
	return b.String()
}

func oneLineGoExpr(e goast.Expr) string {
	fset := gotoken.NewFileSet()
	var buf bytes.Buffer
	_ = format.Node(&buf, fset, e)
	return strings.Join(strings.Fields(strings.TrimSpace(buf.String())), " ")
}

func oneLineFromMaybeMulti(s string) string {
	return strings.Join(strings.Fields(strings.TrimSpace(s)), " ")
}

func indentLines(s, indent string) string {
	lines := strings.Split(s, "\n")
	for i := range lines {
		lines[i] = indent + lines[i]
	}
	return strings.Join(lines, "\n")
}

func formatImportGroups(src string) string {
	// Ensure a blank line between stdlib imports and non-stdlib imports.
	// We only handle the common gofmt form:
	//   import (
	//       "fmt"
	//       . "maragu.dev/gomponents"
	//   )
	lines := strings.Split(src, "\n")
	inImport := false
	var out []string
	seenNonStd := false
	insertedGap := false

	for _, line := range lines {
		trim := strings.TrimSpace(line)
		if strings.HasPrefix(trim, "import") && strings.HasSuffix(trim, "(") {
			inImport = true
			seenNonStd = false
			insertedGap = false
			out = append(out, line)
			continue
		}
		if inImport && trim == ")" {
			inImport = false
			out = append(out, line)
			continue
		}
		if inImport {
			// import spec line: maybe starts with . or _ or identifier; find the quoted path.
			q := strings.Index(line, "\"")
			if q >= 0 {
				qq := strings.Index(line[q+1:], "\"")
				if qq >= 0 {
					path := line[q+1 : q+1+qq]
					isStd := isStdImportPath(path)
					if !isStd {
						if !seenNonStd {
							seenNonStd = true
						}
					} else if seenNonStd {
						// std after non-std shouldn't happen with our sorter; ignore
					}
					// Insert gap at boundary: first non-std after last std.
					if !insertedGap && !isStd {
						// If previous output line is a std import (not blank and within import),
						// insert a blank line before this non-std import.
						if len(out) > 0 {
							prev := strings.TrimSpace(out[len(out)-1])
							if prev != "" && prev != "(" && prev != "import (" {
								out = append(out, "")
								insertedGap = true
							}
						}
					}
				}
			}
		}
		out = append(out, line)
	}
	return strings.Join(out, "\n")
}

func isStdImportPath(path string) bool {
	// Heuristic: stdlib imports never have a '.' in the first path segment.
	seg := path
	if i := strings.IndexByte(seg, '/'); i >= 0 {
		seg = seg[:i]
	}
	return !strings.Contains(seg, ".")
}

func fileUsesPkgSelector(f *goast.File, pkg string) bool {
	found := false
	goast.Inspect(f, func(n goast.Node) bool {
		if found || n == nil {
			return false
		}
		if sel, ok := n.(*goast.SelectorExpr); ok {
			if id, ok := sel.X.(*goast.Ident); ok && id.Name == pkg {
				found = true
				return false
			}
		}
		return true
	})
	return found
}

func fileUsesIdent(f *goast.File, name string) bool {
	found := false
	goast.Inspect(f, func(n goast.Node) bool {
		if found || n == nil {
			return false
		}
		if id, ok := n.(*goast.Ident); ok && id.Name == name {
			found = true
			return false
		}
		return true
	})
	return found
}

// --- scanner + GSX tag parsing (subset of previous GSX v0) ---

type scanner struct {
	src []byte
	i   int
}

func (s *scanner) eof() bool { return s.i >= len(s.src) }
func (s *scanner) peek() byte {
	if s.eof() {
		return 0
	}
	return s.src[s.i]
}
func (s *scanner) peekN(n int) byte {
	j := s.i + n
	if j >= len(s.src) {
		return 0
	}
	return s.src[j]
}
func (s *scanner) next() byte {
	if s.eof() {
		return 0
	}
	b := s.src[s.i]
	s.i++
	return b
}
func (s *scanner) startsWith(prefix string) bool {
	return bytes.HasPrefix(s.src[s.i:], []byte(prefix))
}
func (s *scanner) readLineComment() string {
	start := s.i
	for !s.eof() && s.next() != '\n' {
	}
	return string(s.src[start:s.i])
}
func (s *scanner) readBlockComment() string {
	start := s.i
	s.next()
	s.next()
	for !s.eof() && !s.startsWith("*/") {
		s.next()
	}
	if s.startsWith("*/") {
		s.next()
		s.next()
	}
	return string(s.src[start:s.i])
}
func (s *scanner) readStringLit() string {
	start := s.i
	s.next()
	for !s.eof() {
		c := s.next()
		if c == '\\' {
			_ = s.next()
			continue
		}
		if c == '"' {
			break
		}
	}
	return string(s.src[start:s.i])
}
func (s *scanner) readRuneLit() string {
	start := s.i
	s.next()
	for !s.eof() {
		c := s.next()
		if c == '\\' {
			_ = s.next()
			continue
		}
		if c == '\'' {
			break
		}
	}
	return string(s.src[start:s.i])
}
func (s *scanner) readRawString() string {
	start := s.i
	s.next()
	for !s.eof() && s.next() != '`' {
	}
	return string(s.src[start:s.i])
}

func isTagStart(b byte) bool {
	return (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z')
}

func parseTagExpr(s *scanner) (ast.Node, error) {
	// assumes current is '<' and next is tag start
	if s.next() != '<' {
		return nil, fmt.Errorf("internal: expected <")
	}
	tagStart := s.i
	for {
		b := s.peek()
		if (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') || (b >= '0' && b <= '9') || b == '-' {
			s.next()
			continue
		}
		break
	}
	tag := string(s.src[tagStart:s.i])

	var attrs []ast.Attr
	for {
		skipSpace(s)
		if s.startsWith("/>") {
			s.next()
			s.next()
			return ast.Element{Tag: tag, Attrs: attrs, SelfClosing: true}, nil
		}
		if s.peek() == '>' {
			s.next()
			break
		}
		// attribute injection: {expr}
		if s.peek() == '{' {
			expr, err := readBracedSource(s)
			if err != nil {
				return nil, err
			}
			expr, err = rewriteTagsInGoExpr(expr)
			if err != nil {
				return nil, err
			}
			attrs = append(attrs, ast.Attr{Key: "", Kind: ast.AttrExpr, Value: strings.TrimSpace(expr)})
			continue
		}
		key, kind, val, err := parseAttr(s)
		if err != nil {
			return nil, err
		}
		attrs = append(attrs, ast.Attr{Key: key, Kind: kind, Value: val})
	}

	// children until </tag>
	var kids []ast.Node
	for {
		if s.eof() {
			return nil, fmt.Errorf("unexpected EOF in <%s>", tag)
		}
		if s.startsWith("</") {
			s.next()
			s.next()
			closeStart := s.i
			for (s.peek() >= 'a' && s.peek() <= 'z') || (s.peek() >= 'A' && s.peek() <= 'Z') || (s.peek() >= '0' && s.peek() <= '9') || s.peek() == '-' {
				s.next()
			}
			closeTag := string(s.src[closeStart:s.i])
			skipSpace(s)
			if s.peek() != '>' {
				return nil, fmt.Errorf("expected > for </%s>", closeTag)
			}
			s.next()
			if closeTag != tag {
				return nil, fmt.Errorf("mismatched closing tag </%s> for <%s>", closeTag, tag)
			}
			break
		}
		if s.peek() == '<' && isTagStart(s.peekN(1)) {
			n, err := parseTagExpr(s)
			if err != nil {
				return nil, err
			}
			kids = append(kids, n)
			continue
		}
		if s.peek() == '{' {
			expr, err := readBracedSource(s)
			if err != nil {
				return nil, err
			}
			expr, err = rewriteTagsInGoExpr(expr)
			if err != nil {
				return nil, err
			}
			kids = append(kids, ast.Expr{Src: strings.TrimSpace(expr)})
			continue
		}
		// text
		txtStart := s.i
		for !s.eof() {
			b := s.peek()
			if b == '<' || b == '{' {
				break
			}
			s.next()
		}
		if txtStart < s.i {
			v := string(s.src[txtStart:s.i])
			if strings.TrimSpace(v) != "" {
				kids = append(kids, ast.Text{Value: v})
			}
		}
	}

	return ast.Element{Tag: tag, Attrs: attrs, Children: kids}, nil
}

func skipSpace(s *scanner) {
	for {
		b := s.peek()
		if b == ' ' || b == '\t' || b == '\n' || b == '\r' {
			s.next()
			continue
		}
		break
	}
}

func parseAttr(s *scanner) (key string, kind ast.AttrKind, val string, err error) {
	// key
	start := s.i
	for {
		b := s.peek()
		if (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') || (b >= '0' && b <= '9') || b == '-' || b == '_' {
			s.next()
			continue
		}
		break
	}
	key = string(s.src[start:s.i])
	skipSpace(s)
	if s.peek() != '=' {
		return key, ast.AttrBool, "", nil
	}
	s.next()
	skipSpace(s)
	switch s.peek() {
	case '"':
		s.next()
		vstart := s.i
		for !s.eof() && s.peek() != '"' {
			s.next()
		}
		val = string(s.src[vstart:s.i])
		if s.peek() == '"' {
			s.next()
		}
		return key, ast.AttrString, val, nil
	case '{':
		expr, err := readBracedSource(s)
		if err != nil {
			return "", 0, "", err
		}
		expr, err = rewriteTagsInGoExpr(expr)
		if err != nil {
			return "", 0, "", err
		}
		return key, ast.AttrExpr, strings.TrimSpace(expr), nil
	default:
		return "", 0, "", fmt.Errorf("expected attr value for %s", key)
	}
}

func rewriteTagsInGoExpr(expr string) (string, error) {
	s := &scanner{src: []byte(expr)}
	var out strings.Builder
	for !s.eof() {
		if s.startsWith("//") {
			out.WriteString(s.readLineComment())
			continue
		}
		if s.startsWith("/*") {
			out.WriteString(s.readBlockComment())
			continue
		}
		switch s.peek() {
		case '"':
			out.WriteString(s.readStringLit())
			continue
		case '\'':
			out.WriteString(s.readRuneLit())
			continue
		case '`':
			out.WriteString(s.readRawString())
			continue
		case '<':
			if b := s.peekN(1); isTagStart(b) {
				el, err := parseTagExpr(s)
				if err != nil {
					return "", err
				}
				ex, err := gomponents.LowerNodes([]ast.Node{el}, gomponents.Context{VarTypes: map[string]string{}})
				if err != nil {
					return "", err
				}
				clearTokenPos(ex)
				out.WriteString(formatExpr(ex))
				continue
			}
		}
		out.WriteByte(s.next())
	}
	return out.String(), nil
}

func formatExpr(e goast.Expr) string {
	fset := gotoken.NewFileSet()
	var buf bytes.Buffer
	_ = format.Node(&buf, fset, e)
	// Keep embedded expressions single-line to avoid go/printer inserting odd blank lines
	// when the expression later gets parsed as part of a larger file.
	return strings.Join(strings.Fields(strings.TrimSpace(buf.String())), " ")
}

func clearTokenPos(n any) {
	// go/printer uses token.Pos gaps to decide where to insert newlines.
	// Our lowered AST nodes often come from parser.ParseExpr() with a different
	// fileset, which can lead to weird blank lines when printing as part of the
	// larger generated file. Clearing token.Pos normalizes formatting.
	clearTokenPosRV(reflect.ValueOf(n), map[uintptr]bool{})
}

func clearTokenPosRV(v reflect.Value, seen map[uintptr]bool) {
	if !v.IsValid() {
		return
	}
	if v.Kind() == reflect.Pointer {
		if v.IsNil() {
			return
		}
		ptr := v.Pointer()
		if ptr != 0 {
			if seen[ptr] {
				return
			}
			seen[ptr] = true
		}
		clearTokenPosRV(v.Elem(), seen)
		return
	}
	switch v.Kind() {
	case reflect.Struct:
		tPos := reflect.TypeOf(gotoken.Pos(0))
		for i := 0; i < v.NumField(); i++ {
			f := v.Field(i)
			if !f.CanSet() && f.Kind() != reflect.Pointer && f.Kind() != reflect.Slice && f.Kind() != reflect.Struct {
				continue
			}
			if f.Type() == tPos && f.CanSet() {
				f.SetInt(int64(gotoken.NoPos))
				continue
			}
			clearTokenPosRV(f, seen)
		}
	case reflect.Slice, reflect.Array:
		for i := 0; i < v.Len(); i++ {
			clearTokenPosRV(v.Index(i), seen)
		}
	case reflect.Interface:
		if !v.IsNil() {
			clearTokenPosRV(v.Elem(), seen)
		}
	}
}

func readBracedSource(s *scanner) (string, error) {
	if s.peek() != '{' {
		return "", fmt.Errorf("expected {")
	}
	s.next()
	start := s.i
	depth := 1
	for !s.eof() {
		b := s.next()
		switch b {
		case '{':
			depth++
		case '}':
			depth--
			if depth == 0 {
				return string(s.src[start : s.i-1]), nil
			}
		case '"':
			// skip string literal
			for !s.eof() {
				c := s.next()
				if c == '\\' {
					_ = s.next()
					continue
				}
				if c == '"' {
					break
				}
			}
		case '\'':
			for !s.eof() {
				c := s.next()
				if c == '\\' {
					_ = s.next()
					continue
				}
				if c == '\'' {
					break
				}
			}
		case '`':
			for !s.eof() && s.next() != '`' {
			}
		}
	}
	return "", fmt.Errorf("unexpected EOF in braced expr")
}
